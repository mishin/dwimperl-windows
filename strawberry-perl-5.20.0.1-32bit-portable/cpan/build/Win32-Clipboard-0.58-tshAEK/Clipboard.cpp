/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.24 from the
 * contents of Clipboard.xs. Do not edit this file, edit Clipboard.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Clipboard.xs"
/*
#######################################################################
#
# Win32::Clipboard - Interaction with the Windows clipboard
#
# Version: 0.58
# Created: 19 Nov 96
# Author: Aldo Calpini <dada@perl.it>
#
# Modified: 24 Jul 2004
# By: Hideyo Imazu <h@imazu.net>
#
#######################################################################
 */

/* uncomment next line for debug messages */
// #define WIN32__CLIPBOARD__DEBUG

#define  WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <string.h>
#include <wchar.h>
#include <winuser.h>
#include <shellapi.h>

#define __TEMP_WORD  WORD   /* perl defines a WORD, yikes! */

#ifdef __cplusplus
#include <stdlib.h>
#include <math.h>
extern "C" {
#endif

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#ifdef __cplusplus
}
#endif

#include "ppport.h"

#undef WORD
#define WORD __TEMP_WORD

// Section for the constant definitions.
#define CROAK croak
#define MAX_LENGTH 2048
#define TMPBUFSZ 1024

static HWND hwndThisViewer;
static HWND hwndNextViewer;
static HANDLE hEvt;
static HANDLE hThread;

/* DLL entry point */
BOOL WINAPI DllMain(HINSTANCE hDll, DWORD reason, LPVOID reserved) {
    //    BOOL ccb;
#ifdef WIN32__CLIPBOARD__DEBUG
    printf("!XS(DllMain): DLL entry point called with reason: %ld\n", reason);
    printf("!XS(DllMain): ClipboardViewer is: %ld\n", GetClipboardViewer());
#endif
    if((reason == DLL_THREAD_ATTACH ||
        reason == DLL_THREAD_DETACH) && hwndThisViewer) {
#ifdef WIN32__CLIPBOARD__DEBUG
        printf("!XS(DllMain): hwndThisViewer=%ld\n", hwndThisViewer);
        printf("!XS(DllMain): hwndNextViewer=%ld\n", hwndNextViewer);
        printf("!XS(DllMain): ClipboardViewer is: %ld\n", GetClipboardViewer());
#endif
        // Remove the window from the Clipboard viewers chain
        // ccb = ChangeClipboardChain(hwndThisViewer, hwndNextViewer);
        // printf("\tChangeClipboardChain(%ld,%ld).result = %d\n", hwndThisViewer, hwndNextViewer, ccb);
        // Inform the next window we're closing
        // SendMessage(hwndNextViewer,
        //             WM_CHANGECBCHAIN,
        //             (WPARAM) hwndThisViewer,
        //             (LPARAM) hwndNextViewer);

        // kill the window
        SendMessage(hwndThisViewer, WM_DESTROY, 0, 0);
        // DestroyWindow(hwndThisViewer);
        // SendMessage(hwndThisViewer, WM_QUIT, 0, 0);
#ifdef WIN32__CLIPBOARD__DEBUG
        printf("!XS(DllMain): ClipboardViewer is now: %ld\n", GetClipboardViewer());
#endif
    }
	return TRUE;
}

/* Clipboard Viewer Window Procedure */
LRESULT CALLBACK ClipboardViewerWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

    BOOL ccb;

    // printf("!XS(ClipboardViewerWndProc): got uMsg=%d\n", uMsg);
    switch(uMsg) {
    case WM_CREATE:
#ifdef WIN32__CLIPBOARD__DEBUG
        printf("!XS(ClipboardViewerWndProc): got WM_CREATE\n");
#endif
        hwndNextViewer = SetClipboardViewer(hwnd);
#ifdef WIN32__CLIPBOARD__DEBUG
        printf("!XS(ClipboardViewerWndProc): hwndNextViewer=%ld\n", hwndNextViewer);
        printf("!XS(ClipboardViewerWndProc): ClipboardViewer is now: %ld\n", GetClipboardViewer());
#endif
        break;
    case WM_DRAWCLIPBOARD:
#ifdef WIN32__CLIPBOARD__DEBUG
        printf("!XS(ClipboardViewerWndProc): got WM_DRAWCLIPBOARD (my hwnd is %ld)\n", hwnd);
#endif
        // pass the message to the next viewer
        SendMessage(hwndNextViewer, uMsg, wParam, lParam);
        // stop waiting
        SetEvent(hEvt);
        break;
    case WM_CHANGECBCHAIN:
#ifdef WIN32__CLIPBOARD__DEBUG
        printf("!XS(ClipboardViewerWndProc): got WM_CHANGECBCHAIN\n");
#endif
        // If the next window is closing, repair the chain.
        if ((HWND) wParam == hwndNextViewer)
            hwndNextViewer = (HWND) lParam;
        // Otherwise, pass the message to the next link.
        else if (hwndNextViewer != NULL)
            SendMessage(hwndNextViewer, uMsg, wParam, lParam);
#ifdef WIN32__CLIPBOARD__DEBUG
        printf("!XS(ClipboardViewerWndProc): ClipboardViewer is now: %ld\n", GetClipboardViewer());
#endif
        break;
    case WM_DESTROY:
#ifdef WIN32__CLIPBOARD__DEBUG
        printf("!XS(ClipboardViewerWndProc): got WM_DESTROY\n");
        printf("!XS(ClipboardViewerWndProc): ClipboardViewer is: %ld\n", GetClipboardViewer());
#endif
        ccb = ChangeClipboardChain(hwnd, hwndNextViewer);
#ifdef WIN32__CLIPBOARD__DEBUG
        printf("!XS(ClipboardViewerWndProc): ChangeClipboardChain(%ld,%ld).result = %d\n", hwnd, hwndNextViewer, ccb);
        printf("!XS(ClipboardViewerWndProc): ClipboardViewer is now: %ld\n", GetClipboardViewer());
#endif
        // ChangeClipboardChain(hwnd, hwndNextViewer);
        CloseHandle(hEvt);
        // ExitThread(0);
        PostQuitMessage(0);
        break;
    case WM_QUIT:
#ifdef WIN32__CLIPBOARD__DEBUG
        printf("!XS(ClipboardViewerWndProc): got WM_QUIT\n");
        printf("!XS(ClipboardViewerWndProc): ClipboardViewer is now: %ld\n", GetClipboardViewer());
#endif
        break;
    default:
#ifdef WIN32__CLIPBOARD__DEBUG
        printf("!XS(ClipboardViewerWndProc): got %d\n", uMsg);
#endif
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return (LRESULT) NULL;
}

// msgs: 36, 129, 131, 1, 776
//       24,  81,  83, 1, 308


/* ClipboardViewer Thread Function */
DWORD WINAPI ClipboardViewer(LPVOID hEvt) {

    WNDCLASSEX wcx;
    MSG msg;
    HWND hwnd;
    int stayhere;

    ZeroMemory(&wcx, sizeof(WNDCLASSEX));
    wcx.cbSize = sizeof(WNDCLASSEX);
    wcx.lpfnWndProc = ClipboardViewerWndProc;
    wcx.lpszClassName = "PERL-CLIPBOARD-VIEWER";

    if(RegisterClassEx(&wcx)) {
        if(hwnd = CreateWindowEx(
			0,
            wcx.lpszClassName,
            "", 0,
            1, 1, 1, 1,
            NULL, // perl_hwnd,
            NULL, NULL, NULL)
        ) {
            hwndThisViewer = hwnd;

            // manage the window
            stayhere = 1;
            while (stayhere) {
                stayhere = GetMessage(&msg, hwnd, 0, 0);
                if(stayhere == -1) {
                    stayhere = 0;
                } else {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
            return 1;
        } else {
#ifdef WIN32__CLIPBOARD__DEBUG
            printf("!XS(ClipboardViewer): CreateWindowEx FAILED (%d)\n", GetLastError());
#endif
        }
    } else {
#ifdef WIN32__CLIPBOARD__DEBUG
        printf("!XS(ClipboardViewer): RegisterClassEx FAILED (%d)\n", GetLastError());
#endif
    }
    return 0;
}

HANDLE StartClipboardViewer() {

    DWORD CBVid;
    HANDLE CBVhandle;

    hEvt = CreateEvent(NULL, TRUE, TRUE, "PERL_CLIPBOARD_VIEWER");
#ifdef WIN32__CLIPBOARD__DEBUG
    // printf("!XS(StartClipboardViewer): hEvt=%ld\n", hEvt);
#endif
    CBVhandle = CreateThread(
        NULL, 0,
        (LPTHREAD_START_ROUTINE) ClipboardViewer,
        NULL,
        0,
        &CBVid
    );
    if(CBVhandle == NULL) {
#ifdef WIN32__CLIPBOARD__DEBUG
        printf("!XS(StartClipboardViewer): CreateThread FAILED (%d)\n", GetLastError());
#endif
        return NULL;
    } else {
#ifdef WIN32__CLIPBOARD__DEBUG
        printf("!XS(StartClipboardViewer): Thread created (%ld)\n", CBVhandle);
#endif
        return CBVhandle;
    }
}

long
constant(char *name, int arg)
{
    errno = 0;
	if (strEQ(name, "CF_TEXT"))
#ifdef CF_TEXT
			return CF_TEXT;
#else
			goto not_there;
#endif
	if (strEQ(name, "CF_BITMAP"))
#ifdef CF_BITMAP
			return CF_BITMAP;
#else
			goto not_there;
#endif
	if (strEQ(name, "CF_METAFILEPICT"))
#ifdef CF_METAFILEPICT
			return CF_METAFILEPICT;
#else
			goto not_there;
#endif
	if (strEQ(name, "CF_SYLK"))
#ifdef CF_SYLK
			return CF_SYLK;
#else
			goto not_there;
#endif
	if (strEQ(name, "CF_DIF"))
#ifdef CF_DIF
			return CF_DIF;
#else
			goto not_there;
#endif
	if (strEQ(name, "CF_TIFF"))
#ifdef CF_TIFF
			return CF_TIFF;
#else
			goto not_there;
#endif
	if (strEQ(name, "CF_OEMTEXT"))
#ifdef CF_OEMTEXT
			return CF_OEMTEXT;
#else
			goto not_there;
#endif
	if (strEQ(name, "CF_DIB"))
#ifdef CF_DIB
			return CF_DIB;
#else
			goto not_there;
#endif
	if (strEQ(name, "CF_PALETTE"))
#ifdef CF_PALETTE
			return CF_PALETTE;
#else
			goto not_there;
#endif
	if (strEQ(name, "CF_PENDATA"))
#ifdef CF_PENDATA
			return CF_PENDATA;
#else
			goto not_there;
#endif
	if (strEQ(name, "CF_RIFF"))
#ifdef CF_RIFF
			return CF_RIFF;
#else
			goto not_there;
#endif
	if (strEQ(name, "CF_WAVE"))
#ifdef CF_WAVE
			return CF_WAVE;
#else
			goto not_there;
#endif
	if (strEQ(name, "CF_UNICODETEXT"))
#ifdef CF_UNICODETEXT
			return CF_UNICODETEXT;
#else
			goto not_there;
#endif
	if (strEQ(name, "CF_ENHMETAFILE"))
#ifdef CF_ENHMETAFILE
			return CF_ENHMETAFILE;
#else
			goto not_there;
#endif
	if (strEQ(name, "CF_HDROP"))
#ifdef CF_HDROP
			return CF_HDROP;
#else
			goto not_there;
#endif
	if (strEQ(name, "CF_LOCALE"))
#ifdef CF_LOCALE
			return CF_LOCALE;
#else
			goto not_there;
#endif
    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
}

int
study_dib(HANDLE h, PBITMAPFILEHEADER p_hdr)
{
    LPBITMAPINFO bmi;
    int bitCount;
    int clrUsed;
    int mask_bytes = 0;
    int rgbquad_array_length;
    int dib_offset, dib_size;
    bmi = (LPBITMAPINFO) h;
    bitCount = bmi->bmiHeader.biBitCount;
    clrUsed = bmi->bmiHeader.biClrUsed;
    if ( bitCount == 16 || bitCount == 32 ) mask_bytes = 12;
    if ( bitCount < 16 && clrUsed == 0 )
	rgbquad_array_length = 1 << bitCount;
    else
	rgbquad_array_length = clrUsed;
    dib_offset = bmi->bmiHeader.biSize + mask_bytes +
	rgbquad_array_length * sizeof(RGBQUAD);
    dib_size = dib_offset + bmi->bmiHeader.biSizeImage;
    p_hdr->bfType = 0x4d42;        /* 0x42 = "B" 0x4d = "M" */
    p_hdr->bfSize = (DWORD) (sizeof(BITMAPFILEHEADER) + dib_size);
    p_hdr->bfReserved1 = 0;
    p_hdr->bfReserved2 = 0;
    p_hdr->bfOffBits = (DWORD) (sizeof(BITMAPFILEHEADER) + dib_offset);
    return dib_size;
}

#line 389 "Clipboard.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 531 "Clipboard.c"

XS_EUPXS(XS_Win32__Clipboard_constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Clipboard_constant)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "name, arg");
    {
	char *	name = (char *)SvPV_nolen(ST(0))
;
	int	arg = (int)SvIV(ST(1))
;
	long	RETVAL;
	dXSTARG;
#line 388 "Clipboard.xs"
    RETVAL = constant(name, arg);
#line 548 "Clipboard.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32__Clipboard_StartClipboardViewer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Clipboard_StartClipboardViewer)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 395 "Clipboard.xs"
    if(hThread == NULL)
        hThread = StartClipboardViewer();
#line 566 "Clipboard.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Win32__Clipboard_StopClipboardViewer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Clipboard_StopClipboardViewer)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 401 "Clipboard.xs"
    char NextText[1024];
    if(hwndThisViewer) {
#ifdef WIN32__CLIPBOARD__DEBUG
        printf("XS(StartClipboardViewer): hwndThisViewer=%ld\n", hwndThisViewer);
        printf("XS(StartClipboardViewer): hwndNextViewer=%ld\n", hwndNextViewer);
#endif
        GetWindowText(hwndNextViewer, NextText, 1024);
        // DestroyWindow(hwndThisViewer);
        SendMessage(hwndThisViewer, WM_DESTROY, 0, 0);
        SendMessage(hwndThisViewer, WM_QUIT, 0, 0);
        // PostQuitMessage(0);
        // ChangeClipboardChain(hwndThisViewer, hwndNextViewer);
        if(IsWindow(hwndThisViewer)) {
            XSRETURN_IV((long) -1);
        } else {
            hwndThisViewer = NULL;
            XSRETURN_YES;
        }
    } else {
        XSRETURN_NO;
    }
#line 603 "Clipboard.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Win32__Clipboard_WaitForChange); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Clipboard_WaitForChange)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 427 "Clipboard.xs"
    DWORD cause;
	DWORD timeout;

    if(hThread == NULL) {
#ifdef WIN32__CLIPBOARD__DEBUG
        printf("XS(WaitForChange): Starting the clipboard viewer...\n");
#endif
        hThread = StartClipboardViewer();
    }

    // set the event to be waited for
    ResetEvent(hEvt);

	timeout = INFINITE;

	if(items == 1 && !SvROK(ST(0))) { timeout = (DWORD)SvIV(ST(0)); }
	if(items == 2) { timeout = (DWORD)SvIV(ST(1)); }

    cause = WaitForSingleObject(hEvt, timeout);
    EXTEND(SP,1);
    if(cause == WAIT_OBJECT_0)
        XST_mIV(0, 1);
    else if ( cause == WAIT_TIMEOUT )
        XST_mIV(0, 0);
	else
        XST_mNO(0);
    XSRETURN(1);
#line 646 "Clipboard.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Win32__Clipboard_GetText); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Clipboard_GetText)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 458 "Clipboard.xs"
    HANDLE myhandle;
    if(OpenClipboard(NULL)) {
		EXTEND(SP,1);
		if(myhandle = GetClipboardData(CF_TEXT))
			XST_mPV(0, (char *) myhandle);
		else
			XST_mNO(0);
		CloseClipboard();
		XSRETURN(1);
	} else {
		XSRETURN_NO;
	}
#line 674 "Clipboard.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Win32__Clipboard_GetFiles); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Clipboard_GetFiles)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 474 "Clipboard.xs"
    HANDLE myhandle;
	LPTSTR filename;
	UINT namelength;
	UINT i, toreturn;
	UINT count;
    if ( OpenClipboard(NULL) ) {
		if ( myhandle = GetClipboardData(CF_HDROP) ) {
			count = DragQueryFile((HDROP) myhandle, 0xFFFFFFFF, NULL, 0);
			EXTEND(SP, count);
			for ( i = 0 ; i < count ; i++ ) {
				namelength = DragQueryFile((HDROP) myhandle, i, NULL, 0);
				filename = (LPTSTR) safemalloc(namelength+1);
				DragQueryFile((HDROP) myhandle, i, filename, namelength+1);
				XST_mPV(i, (char *)filename);
				safefree(filename);
			}
			toreturn = count;
		}
                else {
			EXTEND(SP, 1);
			XST_mNO(0);
			toreturn = 1;
		}
		CloseClipboard();
		XSRETURN(toreturn);
	}
    else {
		XSRETURN_NO;
	}
#line 719 "Clipboard.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Win32__Clipboard_GetBitmap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Clipboard_GetBitmap)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 507 "Clipboard.xs"
    HANDLE myhandle;
    BITMAPFILEHEADER hdr;
    SV* buffer;
    int dib_size;
    if ( OpenClipboard(NULL) ) {
	if( myhandle = GetClipboardData(CF_DIB) ) {
	    dib_size = study_dib(myhandle, &hdr);
	    /* Copy the BITMAPFILEHEADER */
	    buffer = sv_2mortal(newSVpvn((char *) &hdr,
					 sizeof(BITMAPFILEHEADER)));
	    /* Copy the DIB data */
	    sv_catpvn(buffer, (char *) myhandle, dib_size);
	    CloseClipboard();
	    EXTEND(SP, 1);
	    XPUSHs(buffer);
	    XSRETURN(1);
	} else {
	    CloseClipboard();
	    XSRETURN_NO;
	}
    } else {
	XSRETURN_NO;
    }
#line 758 "Clipboard.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Win32__Clipboard_GetAs); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Clipboard_GetAs)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "self=NULL, format");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	self;
	int	format = (int)SvIV(ST(1))
;

	if (items < 1)
	    self = NULL;
	else {
	    self = ST(0)
;
	}
#line 536 "Clipboard.xs"
    HANDLE myhandle;
    LPTSTR filename;
    UINT namelength;
    UINT toret;
    UINT count;
    UINT i;
    BITMAPFILEHEADER hdr;
    int dib_size;
    SV* buffer;
    if(items == 1) format = (int)SvIV(ST(0));
    if ( OpenClipboard(NULL) ) {
	switch ( format ) {
	case CF_HDROP:
	    if(myhandle = GetClipboardData(CF_HDROP)) {
		count = DragQueryFile((HDROP) myhandle, 0xFFFFFFFF, NULL, 0);
		EXTEND(SP, count);
		for ( i = 0 ; i < count ; i++ ) {
		    namelength = DragQueryFile((HDROP) myhandle, i, NULL, 0);
		    filename = (LPTSTR) safemalloc(namelength+1);
		    DragQueryFile((HDROP) myhandle, i, filename, namelength+1);
		    XST_mPV(i, (char *)filename);
		    safefree(filename);
		}
		toret = count;
	    }
	    else {
		EXTEND(SP, 1);
		XST_mNO(0);
		toret = 1;
	    }
	    break;
	case CF_DIB:
	    if ( myhandle = GetClipboardData(CF_DIB) ) {
		dib_size = study_dib(myhandle, &hdr);
		/* Copy the BITMAPFILEHEADER */
		buffer = sv_2mortal(newSVpvn((char *) &hdr,
					     sizeof(BITMAPFILEHEADER)));
		/* Copy the DIB data */
		sv_catpvn(buffer, (char *) myhandle, dib_size);
		CloseClipboard();
		EXTEND(SP, 1);
		XPUSHs(buffer);
		XSRETURN(1);
	    } else {
		CloseClipboard();
	    }
	    break;
        case CF_UNICODETEXT:
            EXTEND(SP, 1);
            if (myhandle = GetClipboardData(CF_UNICODETEXT))
                XST_mPVN(0, (char*)myhandle, wcslen((wchar_t*)myhandle) * sizeof(wchar_t));
            else
                XST_mNO(0);
            toret = 1;
            break;
	default:
	    EXTEND(SP, 1);
	    if(myhandle = GetClipboardData((UINT) format))
		XST_mPV(0,(char *) myhandle);
	    else
		XST_mNO(0);
	    toret = 1;
	    break;
	}
        CloseClipboard();
        XSRETURN(toret);
    }
    XSRETURN_NO;
#line 853 "Clipboard.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Win32__Clipboard_Set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Clipboard_Set)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "text, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	text = ST(0)
;
#line 609 "Clipboard.xs"
    HANDLE myhandle;
    HGLOBAL hGlobal;
    LPTSTR szString;
    char *str;
    STRLEN leng;
    if (items > 1)
        text = ST(1);

    str = SvPV(text, leng);
    if ( hGlobal = GlobalAlloc(GMEM_DDESHARE, (leng+1)*sizeof(char)) ) {
        szString = (char *) GlobalLock(hGlobal);
        memcpy(szString, str, leng*sizeof(char));
        szString[leng] = (char) 0;
        GlobalUnlock(hGlobal);

        if ( OpenClipboard(NULL) ) {
            EmptyClipboard();
            myhandle = SetClipboardData(CF_TEXT, (HANDLE) hGlobal);
            CloseClipboard();

            if ( myhandle ) {
                XSRETURN_YES;
            } else {
#ifdef WIN32__CLIPBOARD__DEBUG
                printf("XS(Set): SetClipboardData failed (%d)\n",
                       GetLastError());
#endif
                XSRETURN_NO;
            }
        }
        else {
#ifdef WIN32__CLIPBOARD__DEBUG
            printf("XS(Set): OpenClipboard failed (%d)\n", GetLastError());
#endif
            GlobalFree(hGlobal);
            XSRETURN_NO;
        }
    }
    else {
#ifdef WIN32__CLIPBOARD__DEBUG
        printf("XS(Set): GlobalAlloc failed (%d)\n", GetLastError());
#endif
        XSRETURN_NO;
    }
#line 916 "Clipboard.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Win32__Clipboard_Empty); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Clipboard_Empty)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 657 "Clipboard.xs"
    if(OpenClipboard(NULL)) {
        if(EmptyClipboard()) {
            CloseClipboard();
            XSRETURN_YES;
        } else {
            CloseClipboard();
            XSRETURN_NO;
        }
    }
#line 941 "Clipboard.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Win32__Clipboard_EnumFormats); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Clipboard_EnumFormats)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 671 "Clipboard.xs"
	UINT format;
	int count;
    if ( OpenClipboard(NULL) ) {
		format = EnumClipboardFormats(0);
		count = 0;
		while ( format != 0 ) {
			XST_mIV(count++, (long) format);
			format = EnumClipboardFormats(format);
		}
		CloseClipboard();
    }
    else {
        XSRETURN_NO;
    }
	XSRETURN(count);
#line 972 "Clipboard.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Win32__Clipboard_IsFormatAvailable); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Clipboard_IsFormatAvailable)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "svformat, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	svformat = ST(0)
;
#line 691 "Clipboard.xs"
    if (items > 1)
        svformat = ST(1);
	XST_mIV(0, (long) IsClipboardFormatAvailable((UINT) SvIV(svformat)));
    XSRETURN(1);
#line 995 "Clipboard.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Win32__Clipboard_IsText); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Clipboard_IsText)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
	long	RETVAL;
	dXSTARG;
#line 699 "Clipboard.xs"
	RETVAL = (long) IsClipboardFormatAvailable(CF_TEXT);
#line 1012 "Clipboard.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32__Clipboard_IsBitmap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Clipboard_IsBitmap)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
	long	RETVAL;
	dXSTARG;
#line 706 "Clipboard.xs"
	RETVAL = (long) IsClipboardFormatAvailable(CF_DIB);
#line 1029 "Clipboard.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32__Clipboard_IsFiles); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Clipboard_IsFiles)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
	long	RETVAL;
	dXSTARG;
#line 713 "Clipboard.xs"
	RETVAL = (long) IsClipboardFormatAvailable(CF_HDROP);
#line 1046 "Clipboard.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32__Clipboard_GetFormatName); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Clipboard_GetFormatName)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "svformat, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	svformat = ST(0)
;
#line 721 "Clipboard.xs"
	char * name[1024];
    if (items > 1)
        svformat = ST(1);
	if ( GetClipboardFormatName((UINT) SvIV(svformat), (LPTSTR) name, 1024) ) {
		EXTEND(SP, 1);
		XST_mPV(0, (char *) name);
		XSRETURN(1);
	}
    else {
		XSRETURN_NO;
	}
#line 1076 "Clipboard.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Win32__Clipboard); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Win32__Clipboard)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        newXS("Win32::Clipboard::constant", XS_Win32__Clipboard_constant, file);
        newXS("Win32::Clipboard::StartClipboardViewer", XS_Win32__Clipboard_StartClipboardViewer, file);
        newXS("Win32::Clipboard::StopClipboardViewer", XS_Win32__Clipboard_StopClipboardViewer, file);
        newXS("Win32::Clipboard::WaitForChange", XS_Win32__Clipboard_WaitForChange, file);
        newXS("Win32::Clipboard::GetText", XS_Win32__Clipboard_GetText, file);
        newXS("Win32::Clipboard::GetFiles", XS_Win32__Clipboard_GetFiles, file);
        newXS("Win32::Clipboard::GetBitmap", XS_Win32__Clipboard_GetBitmap, file);
        newXS("Win32::Clipboard::GetAs", XS_Win32__Clipboard_GetAs, file);
        newXS("Win32::Clipboard::Set", XS_Win32__Clipboard_Set, file);
        newXS("Win32::Clipboard::Empty", XS_Win32__Clipboard_Empty, file);
        newXS("Win32::Clipboard::EnumFormats", XS_Win32__Clipboard_EnumFormats, file);
        newXS("Win32::Clipboard::IsFormatAvailable", XS_Win32__Clipboard_IsFormatAvailable, file);
        newXS("Win32::Clipboard::IsText", XS_Win32__Clipboard_IsText, file);
        newXS("Win32::Clipboard::IsBitmap", XS_Win32__Clipboard_IsBitmap, file);
        newXS("Win32::Clipboard::IsFiles", XS_Win32__Clipboard_IsFiles, file);
        newXS("Win32::Clipboard::GetFormatName", XS_Win32__Clipboard_GetFormatName, file);
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

